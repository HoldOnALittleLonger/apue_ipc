UNIX Network Programming Volume 2
 - Interprocess Communications

Chapter 1: Overview
    IPC (interprocess communication):
      It means the methods for message passing between different processes in a system.

    Synchronize (sync):
      A way to guarantee a order between different processes access shared resource concurrently.

    IPC in the book to be discussed:
      <IPC type>                   <persistent>		 <namespace, identifier>
      pipe                         (process-persistent)  (noname, descriptor)
      fifo                         (process-persistent)  (path, descriptor)
      SystemV IPC:
        message queue              (kernel-persistent)   (key_t, SystemV IPC ID)
	semaphore                  (kernel-persistent)   (key_t, SystemV IPC ID)
	shared memory              (kernel-persistent)	 (key_t, SystemV IPC ID)
      Posix IPC:
        message queue              (kernel-persistent)   (Posix IPC name, mqd_t)
	semaphore                  (kernel-persistent)   (Posix IPC name, sem_t)
	unnamed semaphore          (process-persistent)  (noname, sem_t)
	shared memory              (kernel-persistent)	 (Posix IPC name, descriptor)
	mutex                      (process-persistent)  (noname, pthread_mutex_t)
	condition variable         (process-persistent)  (noname, pthread_cond_t)
	(fcntl) record lock        (process-persistent)  (path, descriptor)
	read-write lock            (process-persistent)  (noname, pthread_rwlock_t)
      RPC (Remote Procedure Call)  (by achieving)        (program/version, RPC ID)
      Door	  	    	   (by achieving)	 (path, descriptor)
      Network socket               (process-persistent)  (IP + TCP OR UDP | path, descriptor)

    Evolution of Synchronizing in UNIX:
      a way to sync between processes for write or read a file ->
      record locking ->
      SystemV semaphore ->
      Posix semaphore ->
      mutex ->
      condition variable ->
      read-write lock (it is noe contained in POSIX.1)

    Shared message for process and thread:
      Three method to shared message between processes:
        1>  through filesystem
	2>  through kernel 
	3>  through shared memory

      #  almost all of IPC can used between threads,because in Linux,thread just a task which
         has some process address space and shared process resource.

    Persistence of IPC object:
      persistenct of any type for IPC can be defined as time how long the object of a IPC is existed.
      Three type persistence:
        1>  process-persistent    -
	      exist until the last process exit which holding the IPC object.
	2>  kernel-persistent     -
	      exist until the kernel reboot or delete it in explicitly.
	3>  filesystem-persistent -
	      exist until delete the IPC object explicitly.
	      (because the IPC object exist in filesystem,it will be existing even reboot)

	#  Posix.1 allows to achieve Posix_semaphore Posix_message_queue Posix_shared_memory in
	   different ways.(filesystem or kernel object all is allowed)

    Name Space:
      Name space is a set of available names of IPC for especial type.
      IPC object must has a name or a identifier to identify it.No related processes can access the IPC
      through the identifier.(pipe just such a IPC between related processes)

      #  related processes:
           processes has same parent process of has same grandparent process.
	   in normally,almost all user process has same grandparent process it is a login shell.
      #  Generic standard Name Space is working by Posix.1g workgroup.

    Global variable for error:
      errno  --  <sys/errno.h>
        system call interfaces would use this variable errno to indicates which type of error had happened.
	(IPC interfaces is alike in same behavior)

      #  No any error equal to 0,all error macro definition is begin with 'E'

      Macro for thread environment:
        _REENTRANT                /* can reentry */
	_POSIX_C_SOURCE 199506L   /* POSIX.1 standard 199506L */

	either macro definition would effective thread special errno variable.
	in this case,errno maybe expand to a function and program can use this function to access thread 
	special errno copy.
         
    Standard:
      POSIX: (Poartable Operating System Interface) <ISO/IEC 9945>
        POSIX.1  -  System application program interface(API)[C Language]  (IEEE Std 1003.1-1988)
        POSIX.2  -  Shell and utilities	       				   (IEEE Std 1003.2-1992)
        POSIX.3  -  System administration  (continious working)

	#  Socket and XTI were contained in IEEE Std 1003.1 -- P1003.1g

      X/OPEN:
        XPG  -  X/OPEN Portablity Guide
	SUS  -  Single UNIX standard


Chapter 2 : POSIX IPC
    All posix ipc is contained in REALTIME standard,so if program used them in code,then have to link
    rt library.(-lrt)

    POSIX IPC:
      Message Queue: (detail in Manual) <mqueue.h>
        Service Primitive:
	  mq_open
	  mq_close
	  mq_unlink
	  mq_getattr
	  mq_setattr
	  mq_send
	  mq_receive
	  mq_notify

	struct mq_attr {
	       long mq_flags;
	       long mq_maxmsg;
	       long mq_msgsize;
	       long mq_curmsgs;
	};
      Semaphore: (detail in Manual) <semaphore.h>
        Service Primitive:
	  sem_open
	  sem_close
	  sem_unlink
	  sem_init
	  sem_destroy
	  sem_wait
	  sem_trywait
	  sem_post
	  sem_getvalue
      
      #  posix semaphore is contained in thread standard,so have to link pthread library.(-lpthread)

      Shared Memory: (detail in Manual) <sys/mman.h>
        Service Primitive:
	  shm_open
	  shm_unlink
	  
	  /* these function is unix standard */
	  /* posix shared memory will be abstracted as a file descriptor */
	  ftruncate
	  fstat
	  mmap
	  munmap

    POSIX IPC Name:
      rules of posix ipc name:
        1>  Length of name cant exceed PATH_MAX(contains '\0')
	2>  different between full path and relative path depend on implementation
	3>  interpretation for additional '/' depend on implementation

      additional rules:
        1>  must start with '/'
        2>  only one '/' can appears in posix ipc name

	#  this rule for improve portiablity but not all implementation support.
	   realtime standard attempts to allow achieve POSIX IPC in kernel,the 
	   gain is that posix ipc can works fine on non-disk machine,all resource
	   create in memory.for that,some architecture cant support this.
	   (A standard way of being nonstandard - POSIX)

    POSIX IPC type checking macro:
      bool S_TYPEISMQ(buf);
      bool S_TYPEISSEM(buf);
      bool S_TYPEISSHM(buf);

      buf is a struct type of stat defined in <sys/stat.h>
      in usually,these macro should be inefficiency because of it that they
      depend on type of IPC how to implement.
      if POSIX IPC doesnt implement in a especial file type,then these macro
      always return false.

    POSIX IPC open and create:
      Permission allowed of IPC to be open:
        MQ:
	  O_RDONLY | O_WRONLY | O_RDWR
	SEM:
	  O_RDWR  /* operate a semaphore needs RDWR permission */
	SHM:
	  O_RDONLY | O_RDWR

      Create of IPC:
        MQ AND SEM AND SHM:
	   if not existed,then try to create it.
	   
	   O_CREAT | O_EXCL
	   /* if it existed but assigned O_CREATE | O_EXCL,then return -1,errno = EEXIST */

      NONBlock open:  /* O_NONBLOCK */
        MQ

      Truncate:
        /* if it existed,allow to trunc it */
	SHM

      User-ID and Group-ID:
        MQ:
	  user-id = process effective user-id
	  group-id = process effective group-id 

	SEM AND SHM:
	  user-id = process effective user-id
	  group-id = process effective group-id OR a effective system default group-id
	  /* open() a file,the group id could be process group-id or directory group-id */

      Permission checking when open or create a POSIX IPC:
        point to be depened for checking:
	  1>  permission from create IPC
	  2>  permission from accessing
	  3>  user-id and group-id

	order for checking:
	  if (process user-id == 0)
	    allow();
	  else if (user-id == process user-id && permission == accessing permission)
	    allow();
	  else if ((group-id == process group-id || group-id == process attached group-id)
	       	  && permission == accessing permission)
	    allow();
	  else if (other-user-permission == accessing permission)
	    allow();
	  else
	    refuse();

      Figure for open POSIX IPC:
        open -> if existed {
	     	  if O_CREAT | O_EXCL is true
		    open failed
		  else if permission approve
		    open successed  /* this would open a POSIX IPC which is existed */
		  else
		    open failed
	     	}
		else {
		  if O_CREAT is true
		     if resource avaiable
		       open successed  /* this would create a POSIX IPC */
		     else
		       open failed
		  else
		    open failed
		}

Chapter 3 : SystemV IPC
    SystemV IPC is not supported by Posix.2,it was contained in Unix98.

    SystemV IPC:
      Message Queue: <sys/msg.h>
        Service Primitive:
	  msgget
	  msgctl
	  msgsnd
	  msgrcv

      Semaphore: <sys/sem.h>
        Service Primitive:
	  semget
	  semctl
	  semop

      Shared Memory: <sys/shm.h>
        Service Primitive:
	  shmget
	  shmctl
	  shmat
	  shmdt
        
    SystemV IPC Name:
      SystemV IPC use a value of key_t as key name,this value is combined by path and id via ftok().

      <sys/types.h>
      <sys/ipc.h>
      key_t ftok(const char *pathname, int proj_id);
      >>  in normally,ftok() would take stat.st_dev and stat.st_ino of pathname,and combines these value with the
          low 8bits of proj_id,then return result as key_t.
	  (if proj_id == 0,then behavior of ftok() is undefined,but in glibc,no such request)

      #  Special key for SystemV IPC is IPC_PRIVATE(equal to 0 normally),
         XXXget() can use this key to create a unique IPC object.but this IPC object should not used by
	 processes they are not relative.

    SystemV IPC struct ipc_perm:
      kernel maintains a struct ipc_perm for each IPC object.

      <sys/ipc.h>
      struct ipc_perm {
        key_t __key;		/*  key_t  */
	uid_t uid;		/*  owner uid  */
	gid_t gid;		/*  owner gid  */
	uid_t cuid;		/*  creator uid  */
	gid_t cgid;		/*  creator gid  */
	unsigned short mode;	/*  permissons  */
	unsigned short __seq;  	/*  sequence number  */
      };

      XXXget() function would use some bits in flag argument to set ipc_perm.mode.
      __key == key argument.
      uid == caller uid.
      gid == caller gid.
      cuid == creator uid.
      cgid == creator gid.
      mode almost like mode in open()(linux),but in UNIX has some difference.
      >>  MSG_R	       (owner permission)
      	  MSG_W
	  MSG_R >> 3   (group permission)
	  MSG_W >> 3
	  MSG_R >> 6   (other permission)
	  MSG_W >> 6
	  SEM_R
	  SEM_A(SEM_W)
	  SEM_R >> 3
	  SEM_A >> 3
	  SEM_R >> 6
	  SEM_A >> 6
	  SHM_R
	  SHM_W
	  SHM_R >> 3
	  SHM_W >> 3
	  SHM_R >> 6
	  SHM_W >> 6
      special flag for XXXget(),IPC_CREATE,IPC_EXCL alike to O_CREATE O_EXCL.
      /*  different IPC has different ipc_perm.mode(detail in manual)  */

      __seq like a refer counter,every IPC object was delete,its value would increase,
      if exceed range then begin from 0.
      >>  reasons of __seq:
      	    1> prevent process scan global IPC object try to does some badly action.
	       everytime to reuse a IPC table item,the identifier returned by XXXget()
	       would add IPC table item number.
	    2> prevent reuse SystemV IPC identifier in short time.

      /*  __seq just increase while creating a IPC via same key,then identifier would be changed  */
      /*  seq: 0 -> 1 -> 2 -> ...  identifier: 0 -> 32768 -> 65536 -> ...  */
      /*  this behavior would be reset until kernel reboot  */

      #  XXXctl() can changes owner ID via IPC_SET command,but cant change creator ID.
      #  ipcs program can report system IPC state,ipcrm program can delete IPC(XXXctl() use IPC_RMID command).

    IPC permission checking:
      first checking:
        XXXget(),if flag open some bits they are closed in ipc_perm.mode.(get a existed IPC)
      second checking:
        check permissions everytime to access IPC object.
	a> uid == 0 OK
	b> uid == ipc_perm.uid OR uid == ipc_perm.cuid AND mode OK
	c> gid == ipc_perm.gid OR gid == ipc_perm.cgid AND mode OK
	d> other,mode(other accessible) OK

    Limit on IPC:
      kernel limit SystemV IPC,but there has a way to change limit via system config parameter(e.g. sysctl)
      default limit range is very small.


Chapter 4 : Messaging between processes(PIPE, FIFO)
    pipe : supports messaging between parent process and child process.
    fifo : supports messaging between no relative processes.

    #  generally,pipe is half-duplex,but some system supports full-duplex pipe(SVR4).
    #  socketpair() function supports full-duplex,it was contained in SVR4.
    #  POSIX.1 and UNIX98 just required half-duplex pipe.
    #  socket is full-duplex(even unix domain socket).

    PIPE :
      <unistd.h>
      int pipe(int fd[2]);
      #  return 0 if succeed,return -1 if fault.
      >>  fd[0] as read,fd[1] as write.

      <stdio.h>
      FILE *popen(const char *command, const char *type);
      #  return FILE pointer if succeed,return NULL if fault.
      >>  command would be executed by shell,type tell shell how to connect this pipe between caller.
      	  type == "r" means caller want read data from command,
	  type == "w" means caller want write data to command.

      int pclose(FILE *stream);
      #  return terminate state of shell if succeed,return -1 if failed.
      >>  close a stream open by popen().

    FIFO : 
      <sys/stat.h>
      <sys/types.h>
      <fcntl.h>
      <unistd.h>
      int mkfifo(const char *pathname, mode_t mode);
      #  return 0 if succeed,return -1 if failed.
      >>  mkfifo() try to creates a named pipe in file-system with the mode.
      	  if such pipe has been existed,mkfifo() will failed.
	  for use the fifo,process have to call open() to open it,
	  use read() or write() to operates it,
	  use close() to close fd,use unlink() to delete the fifo.

    Attributes of pipe and fifo :
      flag O_NONBLOCK set up for pipe and fifo :
        pipe : use fcntl() to set it.
	fifo : specify O_NONBLOCK when call open().

      actions when operates pipe or fifo :
        open fifo with RD, a process open fifo with WR already,
	  return(block), return(nonblock)
	open fifo with RD, no process open fifo with WR already, 
	  block until a process open fifo with WR(block), return(nonblock)
	open fifo with WR, a process open fifo with RD already, 
	  return(block), return(nonblock)
	open fifo with WR, no process open fifo with RD already,
	  block until a process open fifo with RD(block), return ENXIO(nonblock)

	read empty fifo or pipe, pipe or fifo has been opened with WR, 
	  block until data come or the pipe or fifo was closed(block), return EAGAIN(nonblock)
	read empty fifo or pipe, pipe or fifo has not been opened with WR, 
	  return 0(EOF)(block), return 0(EOF)(nonblock)
	
	write pipe or fifo, pipe or fifo has not been opened with RD, 
	  deliver SIGPIPE to caller(block), deliver SIGPIPE to caller(nonblock)
	write pipe or fifo, pipe or fifo has been opeend with RD :
	      (block)
	        if size_n <= PIPE_BUFF
		then
		  if space_of_pipe >= size_n
		  then
		    write all data
		  else
		    block until has space to write (return EAGAIN,nonblock)
		else
		  if space_of_pipe >= 1B
		  then
		    write apart of data
		  else
		    block until has space to write (return EAGAIN,nonblock)

      limit : 
        <limits.h>
        PIPE_BUF : a data size limit of atomic pipe operation defined in <limit.h>,
		   generally is 512B,but there is could be changed for FIFO,
		   POSIX.1 consider FIFO is a pathname variable depends on file-system.
		   so pathconf() and fpathconf() can query its value.

		   #  if size_n > PIPE_BUF,then kernel not promise operation is atomic.
		   #  maybe data1 and data2 interleaving.

        OPEN_MAX : the maxinum size of number for opened files in a process.
		   sysconf() can query its value.

    Single sever,several clients model :
      Procedure :
        Sever -> mkfifo -> open it with read and then open it with write
	-> (cycle point) wait for message from client -> open client's fifo 
	-> send required data by client	-> close client's fifo
	-> enter next cycle

	#  sever open its fifo twice that is to prevent open this fifo
	#  everytimes while client came

	Client -> mkfifo -> open sever fifo for write -> send request
	-> open client fifo for read -> wait data from sever -> close
	-> unlink fifo

	#  there is a convention that is FIFO and PIPE just works based
	#  single direction working.

      A properly request format :
        Request format : "<PID NUMBER> <REQUEST>"

      Concurrent server :
        one-child-per-client :
	  1> fork child server to serve client.
	  2> create child thread to serve client.

      DoS :
        server open client's fifo with BLOCKED,but client never open its fifo.
	server would blocked until restart.

    Atomic attribute of FIFO(PIPE) write :
      data size for write must less than or equal to PIPE_BUF,
      OS will promise the datas from several client never interleaving.

    Attentions :
      if close a FIFO or PIPE,the all data in it would be abanded by kernel.
      FIFO cant be used in NFS.

    Byte stream and message :
      Byte stream : no bound to specify message length,this is the basic UNIX I/O model.
      Message : has bound to specify message length,it is alike to datagram.(UDP, Sun RPC)

      Several method to build Message over Byte stream :
        1> special end flag (\n, \r ...)
	#  but if such flag symbol was contained in data,it would be interpreted as end flag.

	2> explicit length (datagram header)
	#  struct header { size_n, type_id, buffer ... };

	3> one record one connection
	#  this method might cause resource wasting.(create new connection ...)



Chapter 15 : Door
    (Solaris 2.6)
    /*  Linux 3.10 rpc function based Sun RPC  */

    door is a ipc for remote procedure call,it is invented for Spring distributed operating system.
    LPC(local procedure call) : the procedure was called and the caller in same process.
    	      		        it is synchronous call.
				(POSIX thread provides a way to do asynchronous procedure call)
    RPC(remote procedure call) : the procedure was called and the caller in different processes.
    	       		       	 it is asynchronous call.
    	       		         (RPC supports different hosts in network)

    local remote procedure call :
      RPC in host scope,the different processes in same host.

    door :
      a process calls the procedure of another process in a same host.(door supports network communication)
      it is the enter point of procedure which in server process,client use it to access the procedure.
      and it is synchronous call.

      caller and called are communicate in arguments and returns for information exchange.
      
      Solaris 2.6 door is implementation is involves to thread.
      one client to one server thread,so the server door procedure must be thread-safe.

      usage order of door in Solaris 2.6 :
        server :
	  door_create ->  create door,door use descriptor to identify
	  fattach ->      relate filesystem path to door ipc
	  enter block ->  wait for client
	  door_return 	  return result to client
	  
    	client :
	  open ->	  open door path in filesystem
	  door_call ->	  call procedure in server
	  wait server return

      because use descriptor to identify door ipc,so could send door to another process via
      descriptor transfer.

      <door.h>
        typedef struct door_arg {
	    char *data_ptr;		
	    size_t data_size;
	    door_desc_t *desc_ptr;
	    size_t desc_num;
	    char *rbuf;
	    size_t rsize;
	} door_arg_t;

	data_ptr  : call-> ptr to data arguments
		    return-> ptr to data results
	data_size : call-> #bytes of data arguments
		    return-> actual #bytes of data results
	desc_ptr  : call-> ptr to descriptor arguments
		    return-> ptr to descriptor results
	desc_num  : call-> number of descriptor arguments
		    return-> number of descriptor results
	rbuf      : ptr to result buffer
	rsize     : #bytes of result buffer

	the format of arguments and return-values,have to take an agreement ahead between client and server.
	for eazy design,could make encapsulation for arguments or results in a structure type.
	no arguments data_ptr have set to NULL,and data_size set to zero.

	desc_ptr is an array of door_desc_t to save descriptors they would transfer to server or
	receive from server.

	rbuf is the buffer,arguments and results can use same buffer,that means data_ptr and desc_ptr could
	point to rbuf,and it is also OK when return.
	if the size of rbuf is too less that cant save results from server,then door library function would
	allocate a new buffer through mmap() in caller process address space automatically,then update rbuf
	and rsize.if a new buffer was allocated,then user have to call munmap() to unmap the buffer.

	int door_call(int fd, door_arg_t *argp);
	/*
	 *  door_call() should be called by client,it would calls a procedure in server process address space.
	 *  @fd  :  a file descriptor which identify the door ipc,normally,it is returned by open() to open
	 *          door ipc file in filesystem.
	 *  @argp  :  structure pointer points to door_arg_t object which contains call arguments and also used
	 *         :  as result buffer to saves results from server procedure call.
	 *  return - return 0 if succeed,otherwise -1.
	 */

	int door_create(void (*server_procedure)(void *cookie, char *argp, size_t arg_size, door_desc_t *dp,
	    		     			 uint_t n_desc), void *cookie, uint_t attributes);
	/*  @dp : dataptr  */
	/*
	 *  door_create() is such function that create door and returns the descriptor.
	 *  @server_procedure : this procedure would as server function when a door_call occurs.
	 *  @cookie : cookie is as identifier as usual.this parameter would as argument for invoke server_procedure.
	 *  @attributes : attributes for newly created door.
	 *  		  Valid value : (could combine with OR)
	 *		  	      DOOR_UNREF
	 *			      DOOR_UNREF_MULTI
	 *			      DOOR_PRIVATE
	 *			      DOOR_REFUSE_DESC
	 *			      DOOR_NO_CANCEL
	 *  return - return descriptor of door if succeed,otherwise returns -1.
	 */
	    DOOR_PRIVATE : indicates that the door has the server threads poor owns to itself.
	    		   when an client request is came,door library function would create
			   server thread automatically,and the thread would put into process
			   threads poor in default.
	    DOOR_UNREF   : when the number of descriptors that refer to this door drops to one,
	    		   recall server_proc once again,by the time, DOOR_UNREF_DATA designates
			   an unreferenced invocation,as the argp argument passed to server_procedure.
			   in the case of an unreferenced invocation,the values for arg_size,dp and
			   n_desc are 0.only one unreferenced invocation is delivered on behalf of a door.

	/*  the door descriptor is default exist FD_CLOEXEC.
	 *  process forks a child process,just only parent is able to receive request from client,even it still
	 *  open in child.
	 */

	!!  for make a mapping between filesystem path and door descriptor,have to invoke fattach() to map path to
	    door descriptor.client can only access the door via filesystem path.
	!!  function fdetach() undo such mapping.

	int door_return(char *dataptr, size_t datasize, door_desc_t *descptr, size_t *ndesc);
	/*
	 *  door_return - return from a door invocation.just can call this function from server_proc.
	 *  @dataptr : pointer points to result of data.
	 *  @datasize : size of result buffer.
	 *  @descptr : pointer points to result of descriptor.
	 *  @ndesc : pointer points to a buffer where saves the size of result of descriptor.
	 *  return - no return if succeed,otherwise return -1.
	 */

	 int door_cred(door_cred_t *cred);
	 /*
	  *  door_cred - an interface for server to retrive user identifier from door_call.
	  *  @cred : a pointer points to an buffer which hold size same as structure door_cred_t.
	  *  return - return 0 if succeed,otherwise return -1.
	  */

	 typedef struct door_cred {
	     uid_t dc_euid;    /*  effective user ID of client  */
	     gid_t dc_egid;    /*  effective group ID of client  */
	     uid_t dc_ruid;    /*  real user ID of client  */
	     gid_t dc_rgid;    /*  real group ID of client  */
	     pid_t dc_pid;     /*  process ID of client  */
	 } door_cred_t;

	 /*  door_cread should be called in server_proc or in a function which is be called by server_proc.  */

	 int door_info(int fd, door_info_t *info);
	 /*
	  *  door_info - retrive server information by client.
	  *  @fd : door descriptor.
	  *  @info : structure pointer points to door_info_t.
	  *  return - return 0 if succeed,otherwise return -1.
	  */

	 typedef struct door_info {
	     pid_t di_target;			/*  server process ID  */
	     door_ptr_t di_proc;		/*  server procedure  */
	     door_ptr_t di_data;		/*  cookie for server procedure,the first parameter in server_proc */
	     door_attr_t di_attributes;		/*  attributes associated with door  */
	     door_id_t id_uniquifier;		/*  unique number  */
	 } door_info_t;

	 /*  attributes DOOR_LOCAL and DOOR_REVOKE are possible include in di_attributes.
	     DOOR_LOCAL : the procedure is a part of current process
	     DOOR_REVOKE : the server proc had been destroyed by server via door_revoke()
	 */

	 /*  every door would has a unique number in system scope while it is create,di_uniquifier would save the number  */
	 
	 !!  in normally,client calls door_info() to retrive server informations,but server proc could calls this function,too.
	     just pass DOOR_QUERY as the first argument.

	 int door_bind(int fd);
	 /*
	  *  door_bind - bind current calling thread to the thread poor which associated with the door descriptor.
	  *  	       	 if it is been,then implicitly release current calling thread from the thread poor.
	  *  @fd : the door descriptor.
	  *  return - return 0 if succeed,otherwise return -1.
	  */

	 int door_unbind(void);
	 /*
	  *  door_unbind - explicitly unbind current calling thread from the thread poor it had been binded.
	  *  return - return 0 if succeed,otherwise return -1.
	  */

	 int door_revoke(int fd);
	 /*
	  *  door_revoke - undo door accessing.
	  *  @fd : the door descriptor which would be undo accessing.
	  *  return - return 0 if succeed,otherwise return -1.
	  *  !!  a door can only be undo by a process which created this door.
	  */

	 /*  if a door accessing instance in progressing while server process invokes door_revoke,it still
	  *  effective until completed.
	  */

		
          



